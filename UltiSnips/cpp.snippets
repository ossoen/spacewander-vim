snippet us "using ..."
using ${1:std::cout};
endsnippet

snippet uns "using namespace std"
using namespace std;
endsnippet


snippet #d "#define ..."
#define $0
endsnippet

snippet #p "#pragma"
#pragma $0
endsnippet

snippet #ind "#ifndef ... #define ... #endif"
#ifndef ${1:`!p snip.rv = snip.basename.upper()`}_H
#define ${1/([A-Za-z0-9_]+).*/$1/}_H

$0

#endif /* ${1/([A-Za-z0-9_]+).*/$1/}_H */
endsnippet

snippet #ie "#if #endif" !b
#if ${1}
    ${0}
#endif
endsnippet

snippet #I "#include local header (inc)"
#include "${1:`!p snip.rv = snip.basename`}.h"
endsnippet

snippet #i "#include <> (Inc)"
#include <${1:iostream}>
endsnippet

snippet im "main() (main)"
int main()
{
	${1:\/* code *\/}
	return 0;
}
endsnippet

snippet ima "main() (main)"
int main(int argc, char *argv[])
{
	${1:\/* code *\/}
	return 0;
}
endsnippet

snippet for "for loop (for)"
for (int ${1:i} = 0; $1 < ${2:/*end*/}; ++$1) {
	${0:/*code*/}
}
endsnippet

snippet for- "for loop --"
for (int ${1:i} = ${2:start}; $1 > ${3:end}; --$1) {
	${0:/*code*/}
}
endsnippet

snippet fore "for (auto i : container)"
for (auto ${1:i} : ${2:container}) {
	${0:/*code*/}
}
endsnippet

snippet fori "for (auto it = ... it++)"
for (auto ${1:it} = ${2:container}.begin(); ${1:it} != ${3:end}; it++) {
	${0:/*code*/}
}
endsnippet

snippet fori- "for (auto it = ... it--)"
for (auto ${1:it} = ${2:container}.begin(); ${1:it} != ${3:end}; it--) {
	${0:/*code*/}
}
endsnippet

snippet e "Enumeration"
enum ${1}{
	${2:name},
	${3:name2}
};
endsnippet

snippet #h "Include header once only guard"
#ifndef ${1:`!p
if not snip.c:
	import string
	name = re.sub(r'[^A-Za-z0-9]+','_',snip.fn).upper()
	snip.rv = '%s_%s' % (name,"H")
else:
    snip.rv = snip.c`}
#define $1

${0}

#endif /* end of include guard: $1 */

endsnippet

snippet td "Typedef"
typedef ${1:int} ${2:MyCustomType};
endsnippet

snippet wh "while loop"
while (${1:/* condition */}) {
	${0:/*code*/}
}
endsnippet

snippet do "do...while loop (do)"
do {
	${0:/*code*/}
} while(${1:/* condition */})
endsnippet

snippet if "if .. (if)"
if (${1:/* condition */}) {
	${0:/*code*/}
}
endsnippet

snippet ief "if .. else if .. else .. (else)"
if (${1:/* condition */}) {
	${3:/*code*/}
}
else if (${2:/* condition */}) {
	${4:/*code*/}
}
else {
	${0:/*code*/}
}
endsnippet

snippet el "else"
else {
	${0:/* code */}
}
endsnippet

snippet ie "if .. else (ife)"
if (${1:/* condition */}) {
	${2:/* code */}
}
else {
	${3:/* else */}
}
endsnippet

snippet iei "if...else if"
if (${1:/* condition */}) {
	${3:/*code*/}
}
else if (${2:/* condition */}) {
	${4:/*code*/}
}
endsnippet

snippet ei "else if"
else if (${1:/* condition */}) {
	${2:/* code */}
}
endsnippet

snippet sw "switch"
{
case ${2:/*value*/}:
	${4:/*code*/}
	break;
case ${3:/*value*/}:
	${5:/*code*/}
	break;
default:
	${0:/*code*/}
}
endsnippet

snippet ca "case"
case ${1:/* value */}:
	${2:/* code */}
	break;
endsnippet

snippet br "break"
break;
endsnippet

snippet con "continue"
continue;
endsnippet


snippet p "printf .. (printf)"
printf("${1:%s}\n"${2:,/*value*/});
endsnippet

snippet fp "fprintf .. (fprintf)"
fprintf(${1:stderr}, "${2:%s}\n"${3:,/*value*/});
endsnippet

snippet st "struct"
struct 
endsnippet

snippet struct "struct"
struct ${1:`!p snip.rv = (snip.basename or "name") + "_t"`} {
	${0:/* data */}
};
endsnippet

snippet fu "function"
${1:void} ${2:function_name}(${3})
{
	${0:/*code*/}
}
endsnippet

snippet df "function declaration"
${1:void} ${2:function_name}(${3});
endsnippet

snippet v "void"
void $0
endsnippet


snippet r "return"
return ${1:/*something*/};
endsnippet

snippet d "double"
double $0
endsnippet

snippet i " int "
int $0
endsnippet

snippet l "long"
long $0
endsnippet

snippet b "bool"
bool $0
endsnippet

snippet t "true"
true
endsnippet

snippet f "false"
false
endsnippet

snippet fl "float"
float $0
endsnippet

snippet c "char"
char $0
endsnippet

snippet C "const" w
const $0
endsnippet

snippet N "NULL"
NULL
endsnippet

snippet np "nullptr"
nullptr
endsnippet

snippet s "static"
static $0
endsnippet

snippet u "unsigned"
unsigned $0
endsnippet

snippet so "sizeof"
sizeof(${1:type})
endsnippet

snippet ma "malloc"
$2 *${3:var} = ($2 *)malloc(${1:value} * sizeof( ${2:type}));

free($3);
endsnippet

snippet fr "free"
free(${0:value});
endsnippet

snippet omp "openmp"
#pragma omp parallel for
endsnippet

snippet /** "doxgen comment"
/**
 * $0
 */
endsnippet

snippet new "new"
$2 *${1:var} = new ${2:filetype}[${3:num}];
delete []$1;
endsnippet

snippet del "delete"
delete $1;
endsnippet

snippet cls "class"
class ${1:ClassName}
{
$0
};
endsnippet

snippet te "template"
template<typename ${1:T}>
endsnippet

snippet vi "virtual"
virtual $0
endsnippet

snippet op "operator"
operator ${1:*}(${2:params})
endsnippet

# vim:ft=snippets:
