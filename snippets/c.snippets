snippet #d "#define ..."
#define ${1}
endsnippet

snippet #ind "#ifndef ... #define ... #endif"
#ifndef ${1/([A-Za-z0-9_]+).*/$1/}
#define ${1:SYMBOL}
#endif
endsnippet

snippet #id "#if #endif" !b
#if ${1}
    ${0};
#endif
endsnippet

snippet #I "#include local header (inc)"
#include "${1:`!p snip.rv = snip.basename`}.h"
endsnippet

snippet #i "#include <> (Inc)"
#include <${1}.h>
endsnippet

snippet mark "#pragma mark (mark)"
#pragma mark $0
endsnippet

snippet im "main() (main)"
int main()
{
	${1:\/* code *\/)/};
	return 0;
}
endsnippet

snippet ima "main() (main)"
int main(int argc, char *argv[])
{
	${1:\/* code *\/)/}
	return 0;
}
endsnippet

snippet for "for loop (for)"
for (${1:i} = 0; $1 < ${2:/*end*/}; ++$1)
{
	${0:/*code*/}
}
endsnippet

snippet for- "for loop --"
for (${1:i} = ${2:start}; $1 > ${3:end}; --$1)
{
	${0:/*code*/}
}
endsnippet

snippet e "Enumeration"
enum ${1}{
	${2:name},
	${3:name2}
};
endsnippet

snippet #h "Include header once only guard"
#ifndef ${1:`!p
if not snip.c:
	import string
	name = re.sub(r'[^A-Za-z0-9]+','_',snip.fn).upper()
	snip.rv = '%s_%s' % (name,"H")
else:
    snip.rv = snip.c`}
#define $1

${0}

#endif /* end of include guard: $1 */

endsnippet

snippet td "Typedef"
typedef ${1:int} ${2:MyCustomType};
endsnippet

snippet wh "while loop"
while(${1:/* condition */}) {
	${0:/*code*/}
}
endsnippet

snippet do "do...while loop (do)"
do {
	${0:/*code*/}
} while(${1:/* condition */})
endsnippet

snippet if "if .. (if)"
if (${1:/* condition */})
{
	${0:/*code*/}
}
endsnippet

snippet ief "if .. else if .. else .. (else)"
if (${1:/* condition */})
{
	${3:/*code*/}
}
else if (${2:/* condition */})
{
	${4:/*code*/}
}
else 
{
	${0:/*code*/}
}
endsnippet

snippet el "else"
else
{
	${0:/* code */}
}
endsnippet

snippet ie "if .. else (ife)"
if (${1:/* condition */})
{
	${2:/* code */}
}
else
{
	${3:/* else */}
}
endsnippet

snippet sw "switch"
switch(${1:/*var*/})
{
case ${2:/*value*/}:
    ${4:/*code*/}
    break;
case ${3:/*value*/}:
    ${5:/*code*/}
    break;
default:
    ${0:/*code*/}
}
endsnippet

snippet ca "case"
case ${1:/* value */}:
	${2:/* code */}
	break;
endsnippet

snippet p "printf .. (printf)"
printf("${1:%s}\n"${2:,/*value*/});
endsnippet

snippet s "struct"
struct ${1:`!p snip.rv = (snip.basename or "name") + "_t"`}
{
	${0:/* data */}
};
endsnippet

snippet fun "function" b
${1:void} ${2:function_name}(${3})
{
	${0:/*code*/}
}
endsnippet

snippet fund "function declaration" b
${1:void} ${2:function_name}(${3});
endsnippet

snippet r "return"
return ${1:/*something*/};
endsnippet

snippet d "double"
double
endsnippet

snippet i " int " 
int
endsnippet

snippet f "float"
float
endsnippet

snippet N "NULL"
NULL
endsnippet

snippet so "sizeof"
sizeof( ${1:type} )
endsnippet

snippet ma "malloc"
malloc(${0:value});
endsnippet

snippet fr "free"
free(${0:value});
endsnippet

#for Intel MKL#
snippet Mma "MKL_Malloc"
mkl_malloc(${1:value} * sizeof(${2:type}),${0:length});
endsnippet

snippet Mfr "MKL_Free"
mkl_free(${0:value});
endsnippet
# vim:ft=snippets:
